import json
from typing import Self

from iteration_utilities import duplicates
from pydantic import Field
from pydantic import field_validator
from pydantic import model_validator

from openspeleo_lib.constants import COMPASS_MAX_NAME_LENGTH
from openspeleo_lib.errors import DuplicateValueError
from openspeleo_lib.formats.ariane.name_map import ARIANE_MAPPING
from openspeleo_lib.generators import UniqueIDGenerator
from openspeleo_lib.generators import UniqueNameGenerator
from openspeleo_lib.utils import apply_key_mapping


class BaseMixin:
    @model_validator(mode="before")
    @classmethod
    def enforce_snake_and_remove_none(cls, data: dict) -> dict:
        return {k: v for k, v in data.items() if v is not None}

    def to_json(self) -> str:
        """
        Serialize the model to a JSON string with indentation and sorted keys.

        Returns:
            str: The JSON representation of the model.
        """
        return json.dumps(self.model_dump(), indent=4, sort_keys=True)

    @classmethod
    def from_ariane_dict(cls, data, debug=False) -> Self:
        if debug:
            with open(f"{cls.__name__}.import.before.json", mode="w") as f:  # noqa: PTH123
                f.write(json.dumps(data, indent=4, sort_keys=True))
        data = apply_key_mapping(data, mapping=ARIANE_MAPPING.inverse)
        if debug:
            with open(f"{cls.__name__}.import.after.json", mode="w") as f:  # noqa: PTH123
                f.write(json.dumps(data, indent=4, sort_keys=True))
        return cls(**data)

    def to_ariane_dict(self, debug=False) -> dict:
        data = self.model_dump()

        if debug:
            with open("data.export.before.json", mode="w") as f:  # noqa: PTH123
                f.write(json.dumps(data, indent=4, sort_keys=True))

        data = apply_key_mapping(self.model_dump(), mapping=ARIANE_MAPPING)

        if debug:
            with open("data.export.after.json", mode="w") as f:  # noqa: PTH123
                f.write(json.dumps(data, indent=4, sort_keys=True))

        return data

    # ======================== VALIDATOR UTILS ======================== #

    @classmethod
    def validate_unique(cls, field: str, values: list) -> list:
        vals2check = [getattr(val, field) for val in values]
        dupl_vals = list(duplicates(vals2check))
        if dupl_vals:
            raise DuplicateValueError(
                f"[{cls.__name__}] Duplicate value found for `{field}`: "
                f"{dupl_vals}"
            )
        return values


class AutoIdModelMixin:

    id: int = Field(
        default_factory=lambda: UniqueIDGenerator.get(),
    )

    @field_validator("id", mode="before")
    @classmethod
    def validate_unique_id(cls, value: str | int | None) -> int:

        if value is None or value == "":
            return cls.id.default_factory()

        if isinstance(value, str):
            value = int(value)

        UniqueNameGenerator.register(value=value)
        return value


class NameIdModelMixin:

    name_compass: str = Field(
        default_factory=lambda: UniqueNameGenerator.get(str_len=6),
        min_length=2,
        max_length=32
    )

    @field_validator("name_compass", mode="before")
    @classmethod
    def validate_unique_name_compass(cls, value: str | None) -> str:
        """Note: Validators are only ran with custom fed values.
        Not autogenerated ones. Hence we need to register the name."""

        if value is None or value == "":
            return cls.name_compass.default_factory()

        # 1. Verify the name is only composed of valid chars.
        for char in value:
            if char.upper() not in [
                *UniqueNameGenerator.VOCAB,
                *list("_-~:!?.'()[]{}@*&#%|$")
            ]:
                raise ValueError(f"The character `{char}` is not allowed as `name`.")

        if len(value) > COMPASS_MAX_NAME_LENGTH:
            raise ValueError(f"Name {value} is too long, maximum allowed: "
                             f"{COMPASS_MAX_NAME_LENGTH}")

        UniqueNameGenerator.register(value=value)
        return value

        # original_name = value
        # for idx in range(OSPL_MAX_RETRY_ATTEMPTS + 1):
        #     try:
        #         if idx > 0:
        #             value = f"{original_name}-{idx}"
        #         UniqueNameGenerator.register(value=value)
        #         break
        #     except DuplicateValueError:
        #         continue
        # else:
        #     raise MaxRetriesError("Impossible to find an available name for "
        #                                 f"`{original_name}`")

        # if len(value) > COMPASS_MAX_NAME_LENGTH:
        #     raise ValueError(f"Name {value} is too long, maximum allowed: "
        #                      f"{COMPASS_MAX_NAME_LENGTH}")

        # return value
