import uuid
from pathlib import Path

from iteration_utilities import duplicates
from pydantic import UUID4
from pydantic import BaseModel
from pydantic import Field
from pydantic import field_validator
from pydantic import model_validator

from openspeleo_lib.generators import UniqueNameGenerator


class UniqueSubFieldMixin:
    @classmethod
    def validate_unique(cls, field: str, values: list):
        vals2check = [getattr(val, field) for val in values]
        dupl_vals = list(duplicates(vals2check))
        if dupl_vals:
            raise ValueError(
                f"[{cls.__name__}] Duplicate value found for `{field}`: "
                f"{dupl_vals}"
            )
        return values


class BaseMixin:
    id: UUID4 = Field(default_factory=uuid.uuid4)
    name: str = Field(
        default_factory=lambda: UniqueNameGenerator.get(str_len=6),
        min_length=2,
        max_length=32
    )

    @model_validator(mode="before")
    @classmethod
    def remove_name_is_none(cls, data):
        if isinstance(data, dict):
            name = data.pop("name", None)
            if name is not None:
                data["name"] = name
        return data

    @field_validator("name")
    @classmethod
    def validate_name(cls, value: str):
        """Note: Validators are only ran with custom fed values.
        Not autogenerated ones. Hence we need to register the name."""

        # 1. Verify the name is only composed of valid chars.
        for char in value:
            if char.upper() not in [
                *UniqueNameGenerator.VOCAB,
                *list("#-_@!~%&*[]{}()|: ")
            ]:
                raise ValueError(f"The character `{char}` is not allowed as `name`.")

        # 2. Register the name to avoid re-using it.
        UniqueNameGenerator.register(name=value)

        return value


class Shot(BaseMixin, BaseModel):
    pass


class Section(BaseMixin, UniqueSubFieldMixin, BaseModel):
    shots: list[Shot] = []

    @field_validator("shots")
    @classmethod
    def validate_shots_unique(cls, values: list[Shot]):
        return cls.validate_unique(field="id", values=values)


class Survey(UniqueSubFieldMixin, BaseModel):
    id: UUID4 = Field(default_factory=uuid.uuid4)
    name: str
    sections: list[Section] = []

    @property
    def shots(self):
        return [
            shot
            for section in self.sections
            for shot in section.shots
        ]

    @field_validator("sections")
    @classmethod
    def validate_shots_unique(cls, values):

        # 1. validate shots are unique
        shots = [shot for section in values for shot in section.shots]
        _ = cls.validate_unique(field="id", values=shots)
        _ = cls.validate_unique(field="name", values=shots)

        # 2. validate sections are unique
        _ = cls.validate_unique(field="id", values=values)
        _ = cls.validate_unique(field="name", values=values)

        return values

    @classmethod
    def from_compass_file(cls, filepath: Path):
        from compass_lib.parser import CompassParser

        if not filepath.exists():
                raise FileNotFoundError(f"File not found: `{filepath}`")

        survey = CompassParser(filepath)

        return cls(name="")

    @classmethod
    def from_ariane_file(cls, filepath):
        from ariane_lib.parser import ArianeParser

        if not filepath.exists():
                raise FileNotFoundError(f"File not found: `{filepath}`")
        survey = ArianeParser(filepath)

        sections = []
        for section in survey.sections:
            shots = [Shot(name=shot.name) for shot in section.shots]
            sections.append(Section(name=section.name, shots=shots))

        return cls(name=survey.name, sections=sections)


